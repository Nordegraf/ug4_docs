<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>ug4: ug::ILinearOperatorInverse&lt; X, Y &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra_stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ug4
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>ug4</span></a></li>
      <li><a href="usergroup0.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classug_1_1_i_linear_operator_inverse.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classug_1_1_i_linear_operator_inverse-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ug::ILinearOperatorInverse&lt; X, Y &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>describes an inverse linear mapping X-&gt;Y  
 <a href="classug_1_1_i_linear_operator_inverse.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="linear__operator__inverse_8h_source.html">linear_operator_inverse.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for ug::ILinearOperatorInverse&lt; X, Y &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="classug_1_1_i_linear_operator_inverse.png" usemap="#ug::ILinearOperatorInverse_3C_20X_2C_20Y_20_3E_map" alt=""/>
  <map id="ug::ILinearOperatorInverse_3C_20X_2C_20Y_20_3E_map" name="ug::ILinearOperatorInverse&lt; X, Y &gt;_map">
<area href="classug_1_1_i_linear_iterator.html" title="describes a linear iterator " alt="ug::ILinearIterator&lt; X, Y &gt;" shape="rect" coords="122,0,356,24"/>
<area href="classug_1_1_analyzing_solver.html" alt="ug::AnalyzingSolver&lt; M, X, Y &gt;" shape="rect" coords="0,112,234,136"/>
<area href="classug_1_1_i_matrix_operator_inverse.html" title="describes an inverse linear mapping X-&gt;Y based on a matrix " alt="ug::IMatrixOperatorInverse&lt; M, X, Y &gt;" shape="rect" coords="244,112,478,136"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a8387a2ae12614bef183a9bd8faf1bac6"><td class="memItemLeft" align="right" valign="top">typedef Y&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_i_linear_operator_inverse.html#a8387a2ae12614bef183a9bd8faf1bac6">codomain_function_type</a></td></tr>
<tr class="memdesc:a8387a2ae12614bef183a9bd8faf1bac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Range space.  <a href="#a8387a2ae12614bef183a9bd8faf1bac6">More...</a><br /></td></tr>
<tr class="separator:a8387a2ae12614bef183a9bd8faf1bac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fff78c606557a2624cc2578620f26ce"><td class="memItemLeft" align="right" valign="top">typedef X&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_i_linear_operator_inverse.html#a8fff78c606557a2624cc2578620f26ce">domain_function_type</a></td></tr>
<tr class="memdesc:a8fff78c606557a2624cc2578620f26ce"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classug_1_1_domain.html">Domain</a> space.  <a href="#a8fff78c606557a2624cc2578620f26ce">More...</a><br /></td></tr>
<tr class="separator:a8fff78c606557a2624cc2578620f26ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classug_1_1_i_linear_iterator"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classug_1_1_i_linear_iterator')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classug_1_1_i_linear_iterator.html">ug::ILinearIterator&lt; X, Y &gt;</a></td></tr>
<tr class="memitem:a7a54a9eabc77a3121f5526febb25d825 inherit pub_types_classug_1_1_i_linear_iterator"><td class="memItemLeft" align="right" valign="top">typedef Y&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_i_linear_iterator.html#a7a54a9eabc77a3121f5526febb25d825">codomain_function_type</a></td></tr>
<tr class="memdesc:a7a54a9eabc77a3121f5526febb25d825 inherit pub_types_classug_1_1_i_linear_iterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Range space.  <a href="#a7a54a9eabc77a3121f5526febb25d825">More...</a><br /></td></tr>
<tr class="separator:a7a54a9eabc77a3121f5526febb25d825 inherit pub_types_classug_1_1_i_linear_iterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a8964b8c1e183414871acf84083cb3e inherit pub_types_classug_1_1_i_linear_iterator"><td class="memItemLeft" align="right" valign="top">typedef X&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_i_linear_iterator.html#a8a8964b8c1e183414871acf84083cb3e">domain_function_type</a></td></tr>
<tr class="memdesc:a8a8964b8c1e183414871acf84083cb3e inherit pub_types_classug_1_1_i_linear_iterator"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classug_1_1_domain.html">Domain</a> space.  <a href="#a8a8964b8c1e183414871acf84083cb3e">More...</a><br /></td></tr>
<tr class="separator:a8a8964b8c1e183414871acf84083cb3e inherit pub_types_classug_1_1_i_linear_iterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6ec9b0fd290b9259e6600cfc471ae55b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_i_linear_operator_inverse.html#a6ec9b0fd290b9259e6600cfc471ae55b">apply</a> (Y &amp;u, const X &amp;f)=0</td></tr>
<tr class="memdesc:a6ec9b0fd290b9259e6600cfc471ae55b"><td class="mdescLeft">&#160;</td><td class="mdescRight">applies inverse operator, i.e. returns u = A^{-1} f  <a href="#a6ec9b0fd290b9259e6600cfc471ae55b">More...</a><br /></td></tr>
<tr class="separator:a6ec9b0fd290b9259e6600cfc471ae55b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93c7bd80dbcee94db470ad4ae71f65b4"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_i_linear_operator_inverse.html#a93c7bd80dbcee94db470ad4ae71f65b4">apply_return_defect</a> (Y &amp;u, X &amp;f)=0</td></tr>
<tr class="memdesc:a93c7bd80dbcee94db470ad4ae71f65b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">applies inverse operator, i.e. returns u = A^{-1} f and returns defect d := f - A*u  <a href="#a93c7bd80dbcee94db470ad4ae71f65b4">More...</a><br /></td></tr>
<tr class="separator:a93c7bd80dbcee94db470ad4ae71f65b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68e1c6ce0012b8953ae8d27e2a36e15d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_i_linear_operator_inverse.html#a68e1c6ce0012b8953ae8d27e2a36e15d">apply_update_defect</a> (Y &amp;u, X &amp;f)</td></tr>
<tr class="memdesc:a68e1c6ce0012b8953ae8d27e2a36e15d"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute new correction c = B*d and update defect d := d - A*c  <a href="#a68e1c6ce0012b8953ae8d27e2a36e15d">More...</a><br /></td></tr>
<tr class="separator:a68e1c6ce0012b8953ae8d27e2a36e15d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65c05daf6deb33cbf5cf46f05ce88439"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="classug_1_1_i_linear_iterator.html">ILinearIterator</a>&lt; X, Y &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_i_linear_operator_inverse.html#a65c05daf6deb33cbf5cf46f05ce88439">clone</a> ()</td></tr>
<tr class="memdesc:a65c05daf6deb33cbf5cf46f05ce88439"><td class="mdescLeft">&#160;</td><td class="mdescRight">clone  <a href="#a65c05daf6deb33cbf5cf46f05ce88439">More...</a><br /></td></tr>
<tr class="separator:a65c05daf6deb33cbf5cf46f05ce88439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afce875833c261332bd02e8aee36ca4de"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_i_linear_operator_inverse.html#afce875833c261332bd02e8aee36ca4de">config_string</a> () const </td></tr>
<tr class="memdesc:afce875833c261332bd02e8aee36ca4de"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns information about configuration parameters  <a href="#afce875833c261332bd02e8aee36ca4de">More...</a><br /></td></tr>
<tr class="separator:afce875833c261332bd02e8aee36ca4de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac399dff427d4ab1dfcd43cfa8b0ecacf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_const_smart_ptr.html">ConstSmartPtr</a>&lt; <a class="el" href="classug_1_1_i_convergence_check.html">IConvergenceCheck</a>&lt; X &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_i_linear_operator_inverse.html#ac399dff427d4ab1dfcd43cfa8b0ecacf">convergence_check</a> () const </td></tr>
<tr class="memdesc:ac399dff427d4ab1dfcd43cfa8b0ecacf"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the convergence check  <a href="#ac399dff427d4ab1dfcd43cfa8b0ecacf">More...</a><br /></td></tr>
<tr class="separator:ac399dff427d4ab1dfcd43cfa8b0ecacf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eb8c047393d33c62e600e594f2ecafb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="classug_1_1_i_convergence_check.html">IConvergenceCheck</a>&lt; X &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_i_linear_operator_inverse.html#a0eb8c047393d33c62e600e594f2ecafb">convergence_check</a> ()</td></tr>
<tr class="memdesc:a0eb8c047393d33c62e600e594f2ecafb"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the convergence check  <a href="#a0eb8c047393d33c62e600e594f2ecafb">More...</a><br /></td></tr>
<tr class="separator:a0eb8c047393d33c62e600e594f2ecafb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69f114a6ee3d51052e1601f17fd5ec73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ugbase__common.html#gaf349a0d1e8189254086eb3267fd4f460">number</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_i_linear_operator_inverse.html#a69f114a6ee3d51052e1601f17fd5ec73">defect</a> () const </td></tr>
<tr class="memdesc:a69f114a6ee3d51052e1601f17fd5ec73"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the current defect  <a href="#a69f114a6ee3d51052e1601f17fd5ec73">More...</a><br /></td></tr>
<tr class="separator:a69f114a6ee3d51052e1601f17fd5ec73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46be46d33da2cb8c406aa0bc1f28c5ee"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_i_linear_operator_inverse.html#a46be46d33da2cb8c406aa0bc1f28c5ee">ILinearOperatorInverse</a> ()</td></tr>
<tr class="memdesc:a46be46d33da2cb8c406aa0bc1f28c5ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor setting convergence check to (100, 1e-12, 1e-12, true)  <a href="#a46be46d33da2cb8c406aa0bc1f28c5ee">More...</a><br /></td></tr>
<tr class="separator:a46be46d33da2cb8c406aa0bc1f28c5ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d4e2990fbab02e466d0d546a163d353"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_i_linear_operator_inverse.html#a6d4e2990fbab02e466d0d546a163d353">ILinearOperatorInverse</a> (<a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="classug_1_1_i_convergence_check.html">IConvergenceCheck</a>&lt; X &gt; &gt; spConvCheck)</td></tr>
<tr class="memdesc:a6d4e2990fbab02e466d0d546a163d353"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#a6d4e2990fbab02e466d0d546a163d353">More...</a><br /></td></tr>
<tr class="separator:a6d4e2990fbab02e466d0d546a163d353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf947e1fcaeed6ab77defbfff7939ede"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_i_linear_operator_inverse.html#adf947e1fcaeed6ab77defbfff7939ede">init</a> (<a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="classug_1_1_i_linear_operator.html">ILinearOperator</a>&lt; Y, X &gt; &gt; L)</td></tr>
<tr class="memdesc:adf947e1fcaeed6ab77defbfff7939ede"><td class="mdescLeft">&#160;</td><td class="mdescRight">initializes for the inverse for a linear operator  <a href="#adf947e1fcaeed6ab77defbfff7939ede">More...</a><br /></td></tr>
<tr class="separator:adf947e1fcaeed6ab77defbfff7939ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8835cbcb5314e860107000fc6f3c0cd4"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_i_linear_operator_inverse.html#a8835cbcb5314e860107000fc6f3c0cd4">init</a> (<a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="classug_1_1_i_linear_operator.html">ILinearOperator</a>&lt; Y, X &gt; &gt; J, const Y &amp;u)</td></tr>
<tr class="memdesc:a8835cbcb5314e860107000fc6f3c0cd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">initializes for the inverse for a linearized operator at linearization point u  <a href="#a8835cbcb5314e860107000fc6f3c0cd4">More...</a><br /></td></tr>
<tr class="separator:a8835cbcb5314e860107000fc6f3c0cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3608d8640ae456c216751226adef469a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="classug_1_1_i_linear_operator.html">ILinearOperator</a>&lt; Y, X &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_i_linear_operator_inverse.html#a3608d8640ae456c216751226adef469a">linear_operator</a> ()</td></tr>
<tr class="memdesc:a3608d8640ae456c216751226adef469a"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the current Operator this Inverse Operator is initialized for  <a href="#a3608d8640ae456c216751226adef469a">More...</a><br /></td></tr>
<tr class="separator:a3608d8640ae456c216751226adef469a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cc9a885030f3ec910c1b591a784a970"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_i_linear_operator_inverse.html#a4cc9a885030f3ec910c1b591a784a970">name</a> () const  =0</td></tr>
<tr class="memdesc:a4cc9a885030f3ec910c1b591a784a970"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the name of the operator inverse  <a href="#a4cc9a885030f3ec910c1b591a784a970">More...</a><br /></td></tr>
<tr class="separator:a4cc9a885030f3ec910c1b591a784a970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a325b35c398d98c1683823ee7fefc7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ugbase__common.html#gaf349a0d1e8189254086eb3267fd4f460">number</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_i_linear_operator_inverse.html#af4a325b35c398d98c1683823ee7fefc7">reduction</a> () const </td></tr>
<tr class="memdesc:af4a325b35c398d98c1683823ee7fefc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the current relative reduction  <a href="#af4a325b35c398d98c1683823ee7fefc7">More...</a><br /></td></tr>
<tr class="separator:af4a325b35c398d98c1683823ee7fefc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78adf42b534f257a9918c11a20887db8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_i_linear_operator_inverse.html#a78adf42b534f257a9918c11a20887db8">set_convergence_check</a> (<a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="classug_1_1_i_convergence_check.html">IConvergenceCheck</a>&lt; X &gt; &gt; spConvCheck)</td></tr>
<tr class="memdesc:a78adf42b534f257a9918c11a20887db8"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the convergence check  <a href="#a78adf42b534f257a9918c11a20887db8">More...</a><br /></td></tr>
<tr class="separator:a78adf42b534f257a9918c11a20887db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9de548165426b70bdbb69fd97bc21cad"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_i_linear_operator_inverse.html#a9de548165426b70bdbb69fd97bc21cad">standard_offset</a> () const </td></tr>
<tr class="memdesc:a9de548165426b70bdbb69fd97bc21cad"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the standard offset for output  <a href="#a9de548165426b70bdbb69fd97bc21cad">More...</a><br /></td></tr>
<tr class="separator:a9de548165426b70bdbb69fd97bc21cad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a121300416ece87bd7d2d2f30423ed5cd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_i_linear_operator_inverse.html#a121300416ece87bd7d2d2f30423ed5cd">step</a> () const </td></tr>
<tr class="memdesc:a121300416ece87bd7d2d2f30423ed5cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the current number of steps  <a href="#a121300416ece87bd7d2d2f30423ed5cd">More...</a><br /></td></tr>
<tr class="separator:a121300416ece87bd7d2d2f30423ed5cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0ccaa79974eef8812bf9965227a1261"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_i_linear_operator_inverse.html#af0ccaa79974eef8812bf9965227a1261">supports_parallel</a> () const  =0</td></tr>
<tr class="memdesc:af0ccaa79974eef8812bf9965227a1261"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns if parallel solving is supported  <a href="#af0ccaa79974eef8812bf9965227a1261">More...</a><br /></td></tr>
<tr class="separator:af0ccaa79974eef8812bf9965227a1261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8465be80a5db9ab161e7372fb157139d"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_i_linear_operator_inverse.html#a8465be80a5db9ab161e7372fb157139d">~ILinearOperatorInverse</a> ()</td></tr>
<tr class="memdesc:a8465be80a5db9ab161e7372fb157139d"><td class="mdescLeft">&#160;</td><td class="mdescRight">virtual destructor  <a href="#a8465be80a5db9ab161e7372fb157139d">More...</a><br /></td></tr>
<tr class="separator:a8465be80a5db9ab161e7372fb157139d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classug_1_1_i_linear_iterator"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classug_1_1_i_linear_iterator')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classug_1_1_i_linear_iterator.html">ug::ILinearIterator&lt; X, Y &gt;</a></td></tr>
<tr class="memitem:aa437a6b8395a5ced9f88a4fed5b1bd77 inherit pub_methods_classug_1_1_i_linear_iterator"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="classug_1_1_i_damping.html">IDamping</a>&lt; X, Y &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_i_linear_iterator.html#aa437a6b8395a5ced9f88a4fed5b1bd77">damping</a> ()</td></tr>
<tr class="memdesc:aa437a6b8395a5ced9f88a4fed5b1bd77 inherit pub_methods_classug_1_1_i_linear_iterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the scaling  <a href="#aa437a6b8395a5ced9f88a4fed5b1bd77">More...</a><br /></td></tr>
<tr class="separator:aa437a6b8395a5ced9f88a4fed5b1bd77 inherit pub_methods_classug_1_1_i_linear_iterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefc546bf97351373f54619ab9b5b8a46 inherit pub_methods_classug_1_1_i_linear_iterator"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_i_linear_iterator.html#aefc546bf97351373f54619ab9b5b8a46">ILinearIterator</a> ()</td></tr>
<tr class="memdesc:aefc546bf97351373f54619ab9b5b8a46 inherit pub_methods_classug_1_1_i_linear_iterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor  <a href="#aefc546bf97351373f54619ab9b5b8a46">More...</a><br /></td></tr>
<tr class="separator:aefc546bf97351373f54619ab9b5b8a46 inherit pub_methods_classug_1_1_i_linear_iterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea663dfc186d01de17e335a6e42a57ff inherit pub_methods_classug_1_1_i_linear_iterator"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_i_linear_iterator.html#aea663dfc186d01de17e335a6e42a57ff">ILinearIterator</a> (const <a class="el" href="classug_1_1_i_linear_iterator.html">ILinearIterator</a>&lt; X, Y &gt; &amp;parent)</td></tr>
<tr class="memdesc:aea663dfc186d01de17e335a6e42a57ff inherit pub_methods_classug_1_1_i_linear_iterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy constructor  <a href="#aea663dfc186d01de17e335a6e42a57ff">More...</a><br /></td></tr>
<tr class="separator:aea663dfc186d01de17e335a6e42a57ff inherit pub_methods_classug_1_1_i_linear_iterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2801c0b3a3a7844da204768578aa4e60 inherit pub_methods_classug_1_1_i_linear_iterator"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_i_linear_iterator.html#a2801c0b3a3a7844da204768578aa4e60">set_damp</a> (<a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="classug_1_1_i_damping.html">IDamping</a>&lt; X, Y &gt; &gt; spScaling)</td></tr>
<tr class="memdesc:a2801c0b3a3a7844da204768578aa4e60 inherit pub_methods_classug_1_1_i_linear_iterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets a scaling for the correction  <a href="#a2801c0b3a3a7844da204768578aa4e60">More...</a><br /></td></tr>
<tr class="separator:a2801c0b3a3a7844da204768578aa4e60 inherit pub_methods_classug_1_1_i_linear_iterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1deaa4063fddd6a5b2a409730e81befb inherit pub_methods_classug_1_1_i_linear_iterator"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_i_linear_iterator.html#a1deaa4063fddd6a5b2a409730e81befb">set_damp</a> (<a class="el" href="group__ugbase__common.html#gaf349a0d1e8189254086eb3267fd4f460">number</a> factor)</td></tr>
<tr class="memdesc:a1deaa4063fddd6a5b2a409730e81befb inherit pub_methods_classug_1_1_i_linear_iterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets the damping to a constant factor  <a href="#a1deaa4063fddd6a5b2a409730e81befb">More...</a><br /></td></tr>
<tr class="separator:a1deaa4063fddd6a5b2a409730e81befb inherit pub_methods_classug_1_1_i_linear_iterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7171232f6c9c7d9cdf2e4284b7a37b67 inherit pub_methods_classug_1_1_i_linear_iterator"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_i_linear_iterator.html#a7171232f6c9c7d9cdf2e4284b7a37b67">~ILinearIterator</a> ()</td></tr>
<tr class="memdesc:a7171232f6c9c7d9cdf2e4284b7a37b67 inherit pub_methods_classug_1_1_i_linear_iterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">virtual destructor  <a href="#a7171232f6c9c7d9cdf2e4284b7a37b67">More...</a><br /></td></tr>
<tr class="separator:a7171232f6c9c7d9cdf2e4284b7a37b67 inherit pub_methods_classug_1_1_i_linear_iterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ae2d8ea239673ca5802ded71a6e078891"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="classug_1_1_i_convergence_check.html">IConvergenceCheck</a>&lt; X &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_i_linear_operator_inverse.html#ae2d8ea239673ca5802ded71a6e078891">m_spConvCheck</a></td></tr>
<tr class="memdesc:ae2d8ea239673ca5802ded71a6e078891"><td class="mdescLeft">&#160;</td><td class="mdescRight">smart pointer holding the convergence check  <a href="#ae2d8ea239673ca5802ded71a6e078891">More...</a><br /></td></tr>
<tr class="separator:ae2d8ea239673ca5802ded71a6e078891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a748ce95370ee20696cfda586a47d5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="classug_1_1_i_linear_operator.html">ILinearOperator</a>&lt; Y, X &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_i_linear_operator_inverse.html#a2a748ce95370ee20696cfda586a47d5c">m_spLinearOperator</a></td></tr>
<tr class="memdesc:a2a748ce95370ee20696cfda586a47d5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator that is inverted by this Inverse Operator.  <a href="#a2a748ce95370ee20696cfda586a47d5c">More...</a><br /></td></tr>
<tr class="separator:a2a748ce95370ee20696cfda586a47d5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classug_1_1_i_linear_iterator"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classug_1_1_i_linear_iterator')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classug_1_1_i_linear_iterator.html">ug::ILinearIterator&lt; X, Y &gt;</a></td></tr>
<tr class="memitem:a061ffcb25819046dd8bfba3626049208 inherit pro_attribs_classug_1_1_i_linear_iterator"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="classug_1_1_i_damping.html">IDamping</a>&lt; X, Y &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classug_1_1_i_linear_iterator.html#a061ffcb25819046dd8bfba3626049208">m_spDamping</a></td></tr>
<tr class="memdesc:a061ffcb25819046dd8bfba3626049208 inherit pro_attribs_classug_1_1_i_linear_iterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">the scaling  <a href="#a061ffcb25819046dd8bfba3626049208">More...</a><br /></td></tr>
<tr class="separator:a061ffcb25819046dd8bfba3626049208 inherit pro_attribs_classug_1_1_i_linear_iterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename X, typename Y = X&gt;<br />
class ug::ILinearOperatorInverse&lt; X, Y &gt;</h3>

<p>describes an inverse linear mapping X-&gt;Y </p>
<p>This class is the base class for the inversion of linear operator given in form of the <a class="el" href="classug_1_1_i_linear_operator.html" title="describes a linear mapping X-&gt;Y ">ILinearOperator</a> interface class. Given a operator L, the basic usage of this class is to invert this operator, i.e. to compute the solution u of </p><pre class="fragment">L*u = f     i.e. u := L^{-1} f
</pre><p>This application has been split up into three steps:</p>
<ol type="1">
<li><a class="el" href="classug_1_1_i_linear_operator_inverse.html#adf947e1fcaeed6ab77defbfff7939ede" title="initializes for the inverse for a linear operator ">init()</a>: This method initializes the inverse operator. The inverse operator is initialized the way that, its application will be the inverse application of the operator L passed in by this function. The prepare method can only be called, when this method has been called once.</li>
<li><a class="el" href="classug_1_1_i_linear_operator_inverse.html#a6ec9b0fd290b9259e6600cfc471ae55b" title="applies inverse operator, i.e. returns u = A^{-1} f ">apply()</a>: This method performs the inversion. Before this method is called the init and prepare methods have to be called.</li>
</ol>
<p>This splitting has been made, since initialization and preparation may be computationally expansive. Thus, the user of this class has the choice when to call this initialization/preparation. E.g. when the operator is applied several times on the same vectors, those have only to be prepared once and the init of the operator is only needed once.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">X</td><td>domain space </td></tr>
    <tr><td class="paramname">Y</td><td>range space </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a8387a2ae12614bef183a9bd8faf1bac6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename X, typename Y = X&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Y <a class="el" href="classug_1_1_i_linear_operator_inverse.html">ug::ILinearOperatorInverse</a>&lt; X, Y &gt;::<a class="el" href="classug_1_1_i_linear_iterator.html#a7a54a9eabc77a3121f5526febb25d825">codomain_function_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Range space. </p>

</div>
</div>
<a class="anchor" id="a8fff78c606557a2624cc2578620f26ce"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename X, typename Y = X&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef X <a class="el" href="classug_1_1_i_linear_operator_inverse.html">ug::ILinearOperatorInverse</a>&lt; X, Y &gt;::<a class="el" href="classug_1_1_i_linear_iterator.html#a8a8964b8c1e183414871acf84083cb3e">domain_function_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classug_1_1_domain.html">Domain</a> space. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a46be46d33da2cb8c406aa0bc1f28c5ee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename X, typename Y = X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classug_1_1_i_linear_operator_inverse.html">ug::ILinearOperatorInverse</a>&lt; X, Y &gt;::<a class="el" href="classug_1_1_i_linear_operator_inverse.html">ILinearOperatorInverse</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructor setting convergence check to (100, 1e-12, 1e-12, true) </p>

</div>
</div>
<a class="anchor" id="a6d4e2990fbab02e466d0d546a163d353"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename X, typename Y = X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classug_1_1_i_linear_operator_inverse.html">ug::ILinearOperatorInverse</a>&lt; X, Y &gt;::<a class="el" href="classug_1_1_i_linear_operator_inverse.html">ILinearOperatorInverse</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="classug_1_1_i_convergence_check.html">IConvergenceCheck</a>&lt; X &gt; &gt;&#160;</td>
          <td class="paramname"><em>spConvCheck</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>

</div>
</div>
<a class="anchor" id="a8465be80a5db9ab161e7372fb157139d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename X, typename Y = X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classug_1_1_i_linear_operator_inverse.html">ug::ILinearOperatorInverse</a>&lt; X, Y &gt;::~<a class="el" href="classug_1_1_i_linear_operator_inverse.html">ILinearOperatorInverse</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>virtual destructor </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a6ec9b0fd290b9259e6600cfc471ae55b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename X, typename Y = X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classug_1_1_i_linear_operator_inverse.html">ug::ILinearOperatorInverse</a>&lt; X, Y &gt;::apply </td>
          <td>(</td>
          <td class="paramtype">Y &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const X &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>applies inverse operator, i.e. returns u = A^{-1} f </p>
<p>This method applies the inverse operator, i.e. u = A^{-1} f. The domain function f remains unchanged. Note, that this method can always be implemented by creating a copy of f and calling apply_return_defect with this copy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>right-hand side </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">u</td><td>solution </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool success flag </dd></dl>

<p>Implements <a class="el" href="classug_1_1_i_linear_iterator.html#a293e586f2b9bc1affab1aed75b89387c">ug::ILinearIterator&lt; X, Y &gt;</a>.</p>

<p>Implemented in <a class="el" href="classug_1_1_f_e_t_i_solver.html#a3136b6107b1e345092781276a4aae5bb">ug::FETISolver&lt; TAlgebra &gt;</a>, <a class="el" href="classug_1_1_primal_subassembled_matrix_inverse.html#adcad50d781980348c559c2aa5ef42126">ug::PrimalSubassembledMatrixInverse&lt; TAlgebra &gt;</a>, <a class="el" href="classug_1_1_primal_subassembled_matrix_inverse.html#adcad50d781980348c559c2aa5ef42126">ug::PrimalSubassembledMatrixInverse&lt; algebra_type &gt;</a>, <a class="el" href="classug_1_1_l_u.html#a8fb5d36856d20a2446f4d10d9ca546ba">ug::LU&lt; TAlgebra &gt;</a>, <a class="el" href="classug_1_1_agglomerating_base.html#a02049063cfb70801676130a67c9774df">ug::AgglomeratingBase&lt; IMatrixOperatorInverse&lt; TAlgebra::matrix_type, TAlgebra::vector_type &gt;, TAlgebra &gt;</a>, <a class="el" href="classug_1_1_auto_linear_solver.html#a4b818cf0139856e664b2d99a5b7fd47a">ug::AutoLinearSolver&lt; TVector &gt;</a>, <a class="el" href="classug_1_1_i_external_solver.html#a33d01db0adaf85469e4464e7f1e700f4">ug::IExternalSolver&lt; TAlgebra &gt;</a>, <a class="el" href="classug_1_1_i_preconditioned_linear_operator_inverse.html#a6d928005ed70d6b18cbd52b330950f9e">ug::IPreconditionedLinearOperatorInverse&lt; X &gt;</a>, <a class="el" href="classug_1_1_i_preconditioned_linear_operator_inverse.html#a6d928005ed70d6b18cbd52b330950f9e">ug::IPreconditionedLinearOperatorInverse&lt; ug::CPUAlgebra::vector_type &gt;</a>, <a class="el" href="classug_1_1_i_preconditioned_linear_operator_inverse.html#a6d928005ed70d6b18cbd52b330950f9e">ug::IPreconditionedLinearOperatorInverse&lt; vector_type &gt;</a>, <a class="el" href="classug_1_1_i_preconditioned_linear_operator_inverse.html#a6d928005ed70d6b18cbd52b330950f9e">ug::IPreconditionedLinearOperatorInverse&lt; TVector &gt;</a>, <a class="el" href="classug_1_1_i_matrix_operator_inverse.html#a4cdc589d8e56cc6f302c1eb48ab153be">ug::IMatrixOperatorInverse&lt; M, X, Y &gt;</a>, <a class="el" href="classug_1_1_i_matrix_operator_inverse.html#a4cdc589d8e56cc6f302c1eb48ab153be">ug::IMatrixOperatorInverse&lt; TAlgebra::matrix_type, TAlgebra::vector_type &gt;</a>, and <a class="el" href="classug_1_1_analyzing_solver.html#a81726e6b4f508c9936b760a92e76d5e0">ug::AnalyzingSolver&lt; M, X, Y &gt;</a>.</p>

<p>Referenced by <a class="el" href="classug_1_1_i_linear_operator_inverse.html#a8835cbcb5314e860107000fc6f3c0cd4">ug::ILinearOperatorInverse&lt; TVector &gt;::init()</a>.</p>

</div>
</div>
<a class="anchor" id="a93c7bd80dbcee94db470ad4ae71f65b4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename X, typename Y = X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classug_1_1_i_linear_operator_inverse.html">ug::ILinearOperatorInverse</a>&lt; X, Y &gt;::apply_return_defect </td>
          <td>(</td>
          <td class="paramtype">Y &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>applies inverse operator, i.e. returns u = A^{-1} f and returns defect d := f - A*u </p>
<p>This method applies the inverse operator, i.e. u = A^{-1} f. The domain function f is changed in the way, that the defect d := f - A*u is returned in the function. This is always useful, when the inverting algorithm can (or must) update the defect during computation (this is e.g. the case for the geometric multigrid method). Note, that this method can always be implemented by calling apply and then computing d := f - A*u.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">f</td><td>right-hand side </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">u</td><td>solution </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool success flag </dd></dl>

<p>Implemented in <a class="el" href="classug_1_1_f_e_t_i_solver.html#a43b2692faa409092411b5febb8035ed6">ug::FETISolver&lt; TAlgebra &gt;</a>, <a class="el" href="classug_1_1_primal_subassembled_matrix_inverse.html#aa1b743b0112fed60c81ec75dd0247748">ug::PrimalSubassembledMatrixInverse&lt; TAlgebra &gt;</a>, <a class="el" href="classug_1_1_primal_subassembled_matrix_inverse.html#aa1b743b0112fed60c81ec75dd0247748">ug::PrimalSubassembledMatrixInverse&lt; algebra_type &gt;</a>, <a class="el" href="classug_1_1_l_u.html#a2545c9ed65b70bbca6ce80ad9def4bb7">ug::LU&lt; TAlgebra &gt;</a>, <a class="el" href="classug_1_1_agglomerating_base.html#aabee465ef13809d6f76de2729a01c14a">ug::AgglomeratingBase&lt; IMatrixOperatorInverse&lt; TAlgebra::matrix_type, TAlgebra::vector_type &gt;, TAlgebra &gt;</a>, <a class="el" href="classug_1_1_auto_linear_solver.html#aa83eea4fc3354a6f88f2429ac8cc426f">ug::AutoLinearSolver&lt; TVector &gt;</a>, <a class="el" href="classug_1_1_i_external_solver.html#add3cd416d38ccb3a7613da729e5c4126">ug::IExternalSolver&lt; TAlgebra &gt;</a>, <a class="el" href="classug_1_1_linear_solver.html#a8ff4853c85ab6ef2cb09f07fd614d157">ug::LinearSolver&lt; TVector &gt;</a>, <a class="el" href="classug_1_1_linear_solver.html#a8ff4853c85ab6ef2cb09f07fd614d157">ug::LinearSolver&lt; ug::CPUAlgebra::vector_type &gt;</a>, <a class="el" href="classug_1_1_bi_c_g_stab.html#af0bd5d38470a33c0a3a2284942ebda25">ug::BiCGStab&lt; TVector &gt;</a>, <a class="el" href="classug_1_1_i_matrix_operator_inverse.html#a4b3d411996979e1917148cbbb77b9e6a">ug::IMatrixOperatorInverse&lt; M, X, Y &gt;</a>, <a class="el" href="classug_1_1_i_matrix_operator_inverse.html#a4b3d411996979e1917148cbbb77b9e6a">ug::IMatrixOperatorInverse&lt; TAlgebra::matrix_type, TAlgebra::vector_type &gt;</a>, <a class="el" href="classug_1_1_g_m_r_e_s.html#a25da68a94ae8ccf497c1f8a7c26384de">ug::GMRES&lt; TVector &gt;</a>, <a class="el" href="classug_1_1_c_g.html#a968edfb0b5846aedf3946f57e5b892c3">ug::CG&lt; TVector &gt;</a>, and <a class="el" href="classug_1_1_analyzing_solver.html#a6e8874fb7e3ae011622c81a7a1da51e1">ug::AnalyzingSolver&lt; M, X, Y &gt;</a>.</p>

<p>Referenced by <a class="el" href="classug_1_1_i_linear_operator_inverse.html#a68e1c6ce0012b8953ae8d27e2a36e15d">ug::ILinearOperatorInverse&lt; TVector &gt;::apply_update_defect()</a>, and <a class="el" href="classug_1_1_i_linear_operator_inverse.html#a8835cbcb5314e860107000fc6f3c0cd4">ug::ILinearOperatorInverse&lt; TVector &gt;::init()</a>.</p>

</div>
</div>
<a class="anchor" id="a68e1c6ce0012b8953ae8d27e2a36e15d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename X, typename Y = X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classug_1_1_i_linear_operator_inverse.html">ug::ILinearOperatorInverse</a>&lt; X, Y &gt;::apply_update_defect </td>
          <td>(</td>
          <td class="paramtype">Y &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">X &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compute new correction c = B*d and update defect d := d - A*c </p>
<p>This method applies the inverse operator, i.e. c = B*d. The domain function d is changed in the way, that the defect d := d - A*c is returned in the function. This is always useful, when the iterating algorithm can (or must) update the defect during computation (this is e.g. the case for the geometric multigrid method). Note, that this method can always be implemented by calling apply and then computing d := d - A*c.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d</td><td>defect </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">u</td><td>correction </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool success flag </dd></dl>

<p>Implements <a class="el" href="classug_1_1_i_linear_iterator.html#a0c0ffc2bfb32edb2cef566b14d815556">ug::ILinearIterator&lt; X, Y &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="classug_1_1_agglomerating_base.html#a0d0ea3931b5da5bfd9b32a06d65b59de">ug::AgglomeratingBase&lt; IMatrixOperatorInverse&lt; TAlgebra::matrix_type, TAlgebra::vector_type &gt;, TAlgebra &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a65c05daf6deb33cbf5cf46f05ce88439"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename X, typename Y = X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt;<a class="el" href="classug_1_1_i_linear_iterator.html">ILinearIterator</a>&lt;X,Y&gt; &gt; <a class="el" href="classug_1_1_i_linear_operator_inverse.html">ug::ILinearOperatorInverse</a>&lt; X, Y &gt;::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>clone </p>

<p>Implements <a class="el" href="classug_1_1_i_linear_iterator.html#acc249ee1efa7994db8e732772728d5c1">ug::ILinearIterator&lt; X, Y &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="classug_1_1_i_external_solver.html#aa6751315c5452012d8201b83fdb6e695">ug::IExternalSolver&lt; TAlgebra &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="afce875833c261332bd02e8aee36ca4de"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename X, typename Y = X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string <a class="el" href="classug_1_1_i_linear_operator_inverse.html">ug::ILinearOperatorInverse</a>&lt; X, Y &gt;::config_string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns information about configuration parameters </p>
<p>this should return necessary information about parameters and possibly calling config_string of subcomponents.</p>
<dl class="section return"><dt>Returns</dt><dd>std::string necessary information about configuration parameters </dd></dl>

<p>Reimplemented from <a class="el" href="classug_1_1_i_linear_iterator.html#aaeefb68d28802e7be46a92038f9008e2">ug::ILinearIterator&lt; X, Y &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="classug_1_1_bi_c_g_stab.html#a6b449a2990a6edbac40b069dd537ef42">ug::BiCGStab&lt; TVector &gt;</a>, <a class="el" href="classug_1_1_l_u.html#abea4bd8c53d25300d3da949a97c3e713">ug::LU&lt; TAlgebra &gt;</a>, <a class="el" href="classug_1_1_agglomerating_solver.html#abd767ae8be19d61fe78a2999281ae614">ug::AgglomeratingSolver&lt; TAlgebra &gt;</a>, <a class="el" href="classug_1_1_g_m_r_e_s.html#a1a33d97a066acefecccfd3cb4a0df51b">ug::GMRES&lt; TVector &gt;</a>, <a class="el" href="classug_1_1_i_preconditioned_linear_operator_inverse.html#afb0a4a85087d9ef1d0817bb63b9eac95">ug::IPreconditionedLinearOperatorInverse&lt; X &gt;</a>, <a class="el" href="classug_1_1_i_preconditioned_linear_operator_inverse.html#afb0a4a85087d9ef1d0817bb63b9eac95">ug::IPreconditionedLinearOperatorInverse&lt; ug::CPUAlgebra::vector_type &gt;</a>, <a class="el" href="classug_1_1_i_preconditioned_linear_operator_inverse.html#afb0a4a85087d9ef1d0817bb63b9eac95">ug::IPreconditionedLinearOperatorInverse&lt; vector_type &gt;</a>, <a class="el" href="classug_1_1_i_preconditioned_linear_operator_inverse.html#afb0a4a85087d9ef1d0817bb63b9eac95">ug::IPreconditionedLinearOperatorInverse&lt; TVector &gt;</a>, and <a class="el" href="classug_1_1_analyzing_solver.html#ac379d57acf590c2e08fa0d392c0d5902">ug::AnalyzingSolver&lt; M, X, Y &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ac399dff427d4ab1dfcd43cfa8b0ecacf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename X, typename Y = X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_const_smart_ptr.html">ConstSmartPtr</a>&lt;<a class="el" href="classug_1_1_i_convergence_check.html">IConvergenceCheck</a>&lt;X&gt; &gt; <a class="el" href="classug_1_1_i_linear_operator_inverse.html">ug::ILinearOperatorInverse</a>&lt; X, Y &gt;::convergence_check </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the convergence check </p>

<p>Referenced by <a class="el" href="classug_1_1_i_linear_operator_inverse.html#a69f114a6ee3d51052e1601f17fd5ec73">ug::ILinearOperatorInverse&lt; TVector &gt;::defect()</a>, <a class="el" href="classug_1_1_i_linear_operator_inverse.html#af4a325b35c398d98c1683823ee7fefc7">ug::ILinearOperatorInverse&lt; TVector &gt;::reduction()</a>, and <a class="el" href="classug_1_1_i_linear_operator_inverse.html#a121300416ece87bd7d2d2f30423ed5cd">ug::ILinearOperatorInverse&lt; TVector &gt;::step()</a>.</p>

</div>
</div>
<a class="anchor" id="a0eb8c047393d33c62e600e594f2ecafb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename X, typename Y = X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt;<a class="el" href="classug_1_1_i_convergence_check.html">IConvergenceCheck</a>&lt;X&gt; &gt; <a class="el" href="classug_1_1_i_linear_operator_inverse.html">ug::ILinearOperatorInverse</a>&lt; X, Y &gt;::convergence_check </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the convergence check </p>

</div>
</div>
<a class="anchor" id="a69f114a6ee3d51052e1601f17fd5ec73"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename X, typename Y = X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#gaf349a0d1e8189254086eb3267fd4f460">number</a> <a class="el" href="classug_1_1_i_linear_operator_inverse.html">ug::ILinearOperatorInverse</a>&lt; X, Y &gt;::defect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the current defect </p>

</div>
</div>
<a class="anchor" id="adf947e1fcaeed6ab77defbfff7939ede"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename X, typename Y = X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classug_1_1_i_linear_operator_inverse.html">ug::ILinearOperatorInverse</a>&lt; X, Y &gt;::init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="classug_1_1_i_linear_operator.html">ILinearOperator</a>&lt; Y, X &gt; &gt;&#160;</td>
          <td class="paramname"><em>L</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>initializes for the inverse for a linear operator </p>
<p>This method passes the operator L that is inverted by this operator. In addition some preparation step can be made.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">L</td><td>linear operator to invert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool success flag </dd></dl>

<p>Implements <a class="el" href="classug_1_1_i_linear_iterator.html#a306fe0f0062f16fe7000c88bf4ffddc3">ug::ILinearIterator&lt; X, Y &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="classug_1_1_auto_linear_solver.html#ad25931c17e6151557cd683947f95a1e2">ug::AutoLinearSolver&lt; TVector &gt;</a>, <a class="el" href="classug_1_1_i_matrix_operator_inverse.html#a5c5852424c46f19055d37a49689e0cdc">ug::IMatrixOperatorInverse&lt; M, X, Y &gt;</a>, <a class="el" href="classug_1_1_i_preconditioned_linear_operator_inverse.html#a1c4048bb920a8c511da76c1d59f3d0df">ug::IPreconditionedLinearOperatorInverse&lt; X &gt;</a>, <a class="el" href="classug_1_1_i_matrix_operator_inverse.html#a5c5852424c46f19055d37a49689e0cdc">ug::IMatrixOperatorInverse&lt; TAlgebra::matrix_type, TAlgebra::vector_type &gt;</a>, <a class="el" href="classug_1_1_i_preconditioned_linear_operator_inverse.html#a1c4048bb920a8c511da76c1d59f3d0df">ug::IPreconditionedLinearOperatorInverse&lt; ug::CPUAlgebra::vector_type &gt;</a>, <a class="el" href="classug_1_1_i_preconditioned_linear_operator_inverse.html#a1c4048bb920a8c511da76c1d59f3d0df">ug::IPreconditionedLinearOperatorInverse&lt; vector_type &gt;</a>, <a class="el" href="classug_1_1_i_preconditioned_linear_operator_inverse.html#a1c4048bb920a8c511da76c1d59f3d0df">ug::IPreconditionedLinearOperatorInverse&lt; TVector &gt;</a>, and <a class="el" href="classug_1_1_analyzing_solver.html#a3816ad7c5f05d7d0e36058804ac84fe0">ug::AnalyzingSolver&lt; M, X, Y &gt;</a>.</p>

<p>Referenced by <a class="el" href="classug_1_1_i_preconditioned_linear_operator_inverse.html#a3ddddbd0149c9c6396a53ea801acf227">ug::IPreconditionedLinearOperatorInverse&lt; TVector &gt;::init()</a>, and <a class="el" href="classug_1_1_auto_linear_solver.html#a4e0289eaa2b144635d0ea466c63f85d3">ug::AutoLinearSolver&lt; TVector &gt;::init_op()</a>.</p>

</div>
</div>
<a class="anchor" id="a8835cbcb5314e860107000fc6f3c0cd4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename X, typename Y = X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classug_1_1_i_linear_operator_inverse.html">ug::ILinearOperatorInverse</a>&lt; X, Y &gt;::init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="classug_1_1_i_linear_operator.html">ILinearOperator</a>&lt; Y, X &gt; &gt;&#160;</td>
          <td class="paramname"><em>J</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Y &amp;&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>initializes for the inverse for a linearized operator at linearization point u </p>
<p>This method passes the linear operator J(u) that should be inverted by this operator. As second argument the linearization point is passed. This is needed e.g. for the geometric multigrid method, that inverts a linearized operator based on coarser grid operators, that have to be initialized based on the linearization point.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">J</td><td>linearized operator to invert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">u</td><td>linearization point </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool success flag </dd></dl>

<p>Implements <a class="el" href="classug_1_1_i_linear_iterator.html#a974eed8cfc9e2bc0b6bbc64a44b4ce8a">ug::ILinearIterator&lt; X, Y &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="classug_1_1_auto_linear_solver.html#afed1fab063bd2db12bde2e96a5ed958b">ug::AutoLinearSolver&lt; TVector &gt;</a>, <a class="el" href="classug_1_1_analyzing_solver.html#a4c9cb4c32ebee7de077bb3674464b3b0">ug::AnalyzingSolver&lt; M, X, Y &gt;</a>, <a class="el" href="classug_1_1_i_preconditioned_linear_operator_inverse.html#a3ddddbd0149c9c6396a53ea801acf227">ug::IPreconditionedLinearOperatorInverse&lt; X &gt;</a>, <a class="el" href="classug_1_1_i_preconditioned_linear_operator_inverse.html#a3ddddbd0149c9c6396a53ea801acf227">ug::IPreconditionedLinearOperatorInverse&lt; ug::CPUAlgebra::vector_type &gt;</a>, <a class="el" href="classug_1_1_i_preconditioned_linear_operator_inverse.html#a3ddddbd0149c9c6396a53ea801acf227">ug::IPreconditionedLinearOperatorInverse&lt; vector_type &gt;</a>, <a class="el" href="classug_1_1_i_preconditioned_linear_operator_inverse.html#a3ddddbd0149c9c6396a53ea801acf227">ug::IPreconditionedLinearOperatorInverse&lt; TVector &gt;</a>, <a class="el" href="classug_1_1_i_matrix_operator_inverse.html#a5e9743a6b0ddccb290b9f5d7eb3ad70f">ug::IMatrixOperatorInverse&lt; M, X, Y &gt;</a>, and <a class="el" href="classug_1_1_i_matrix_operator_inverse.html#a5e9743a6b0ddccb290b9f5d7eb3ad70f">ug::IMatrixOperatorInverse&lt; TAlgebra::matrix_type, TAlgebra::vector_type &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a3608d8640ae456c216751226adef469a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename X, typename Y = X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt;<a class="el" href="classug_1_1_i_linear_operator.html">ILinearOperator</a>&lt;Y,X&gt; &gt; <a class="el" href="classug_1_1_i_linear_operator_inverse.html">ug::ILinearOperatorInverse</a>&lt; X, Y &gt;::linear_operator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the current Operator this Inverse Operator is initialized for </p>

</div>
</div>
<a class="anchor" id="a4cc9a885030f3ec910c1b591a784a970"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename X, typename Y = X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* <a class="el" href="classug_1_1_i_linear_operator_inverse.html">ug::ILinearOperatorInverse</a>&lt; X, Y &gt;::name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the name of the operator inverse </p>
<p>This method returns the name of the inverse operator. This function is typically needed, when the inverse operator is used inside of another and some debug output should be printed</p>
<dl class="section return"><dt>Returns</dt><dd>const char* name of inverse operator </dd></dl>

<p>Implements <a class="el" href="classug_1_1_i_linear_iterator.html#acb5bdac9a9559548eeab91933f7673c9">ug::ILinearIterator&lt; X, Y &gt;</a>.</p>

<p>Implemented in <a class="el" href="classug_1_1_f_e_t_i_solver.html#a2edc38e14637d7ebc77865edeabf0972">ug::FETISolver&lt; TAlgebra &gt;</a>, <a class="el" href="classug_1_1_primal_subassembled_matrix_inverse.html#ac2bd94050d532f820095e260977253d2">ug::PrimalSubassembledMatrixInverse&lt; TAlgebra &gt;</a>, <a class="el" href="classug_1_1_primal_subassembled_matrix_inverse.html#ac2bd94050d532f820095e260977253d2">ug::PrimalSubassembledMatrixInverse&lt; algebra_type &gt;</a>, <a class="el" href="classug_1_1_agglomerating_solver.html#a5a22404494e9e576e6ff5cc71109c077">ug::AgglomeratingSolver&lt; TAlgebra &gt;</a>, <a class="el" href="classug_1_1_analyzing_solver.html#a750ecfc65fd0d260dd9e66e1b6324302">ug::AnalyzingSolver&lt; M, X, Y &gt;</a>, <a class="el" href="classug_1_1_auto_linear_solver.html#a05127be1830128d63c2ba2a4d5adb67f">ug::AutoLinearSolver&lt; TVector &gt;</a>, <a class="el" href="classug_1_1_l_u.html#a2dacd0a109e08bcccf3431e6d1fe0f2a">ug::LU&lt; TAlgebra &gt;</a>, <a class="el" href="classug_1_1_bi_c_g_stab.html#a3a1c43def7f7a19265c7fe644c8c3f7e">ug::BiCGStab&lt; TVector &gt;</a>, <a class="el" href="classug_1_1_g_m_r_e_s.html#a0d49e2b4f43af98f530961affe44ef64">ug::GMRES&lt; TVector &gt;</a>, <a class="el" href="classug_1_1_c_g.html#a2905ac8fded077545cd5f5a5b28554fe">ug::CG&lt; TVector &gt;</a>, <a class="el" href="classug_1_1_linear_solver.html#af6cf44ff720c3f6b713e473b021ab566">ug::LinearSolver&lt; TVector &gt;</a>, <a class="el" href="classug_1_1_linear_solver.html#af6cf44ff720c3f6b713e473b021ab566">ug::LinearSolver&lt; ug::CPUAlgebra::vector_type &gt;</a>, and <a class="el" href="classug_1_1_i_external_solver.html#a6c6f43e800a5f730c69636ae3d2491bf">ug::IExternalSolver&lt; TAlgebra &gt;</a>.</p>

<p>Referenced by <a class="el" href="classug_1_1_i_linear_operator_inverse.html#afce875833c261332bd02e8aee36ca4de">ug::ILinearOperatorInverse&lt; TVector &gt;::config_string()</a>, <a class="el" href="classug_1_1_i_linear_operator_inverse.html#a3608d8640ae456c216751226adef469a">ug::ILinearOperatorInverse&lt; TVector &gt;::linear_operator()</a>, and <a class="el" href="classug_1_1_i_linear_operator_inverse.html#a8465be80a5db9ab161e7372fb157139d">ug::ILinearOperatorInverse&lt; TVector &gt;::~ILinearOperatorInverse()</a>.</p>

</div>
</div>
<a class="anchor" id="af4a325b35c398d98c1683823ee7fefc7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename X, typename Y = X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ugbase__common.html#gaf349a0d1e8189254086eb3267fd4f460">number</a> <a class="el" href="classug_1_1_i_linear_operator_inverse.html">ug::ILinearOperatorInverse</a>&lt; X, Y &gt;::reduction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the current relative reduction </p>

</div>
</div>
<a class="anchor" id="a78adf42b534f257a9918c11a20887db8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename X, typename Y = X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classug_1_1_i_linear_operator_inverse.html">ug::ILinearOperatorInverse</a>&lt; X, Y &gt;::set_convergence_check </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="classug_1_1_i_convergence_check.html">IConvergenceCheck</a>&lt; X &gt; &gt;&#160;</td>
          <td class="paramname"><em>spConvCheck</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>set the convergence check </p>

</div>
</div>
<a class="anchor" id="a9de548165426b70bdbb69fd97bc21cad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename X, typename Y = X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classug_1_1_i_linear_operator_inverse.html">ug::ILinearOperatorInverse</a>&lt; X, Y &gt;::standard_offset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the standard offset for output </p>

<p>Referenced by <a class="el" href="classug_1_1_i_linear_operator_inverse.html#a78adf42b534f257a9918c11a20887db8">ug::ILinearOperatorInverse&lt; TVector &gt;::set_convergence_check()</a>.</p>

</div>
</div>
<a class="anchor" id="a121300416ece87bd7d2d2f30423ed5cd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename X, typename Y = X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classug_1_1_i_linear_operator_inverse.html">ug::ILinearOperatorInverse</a>&lt; X, Y &gt;::step </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the current number of steps </p>

</div>
</div>
<a class="anchor" id="af0ccaa79974eef8812bf9965227a1261"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename X, typename Y = X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classug_1_1_i_linear_operator_inverse.html">ug::ILinearOperatorInverse</a>&lt; X, Y &gt;::supports_parallel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns if parallel solving is supported </p>

<p>Implements <a class="el" href="classug_1_1_i_linear_iterator.html#ae238409348666b536619fd2cda4ea106">ug::ILinearIterator&lt; X, Y &gt;</a>.</p>

<p>Implemented in <a class="el" href="classug_1_1_f_e_t_i_solver.html#ae91335973e85b0fd357e49cee3fafe7e">ug::FETISolver&lt; TAlgebra &gt;</a>, <a class="el" href="classug_1_1_primal_subassembled_matrix_inverse.html#a316a6a0b33a8cb753d9fb3d9a45026ce">ug::PrimalSubassembledMatrixInverse&lt; TAlgebra &gt;</a>, <a class="el" href="classug_1_1_primal_subassembled_matrix_inverse.html#a316a6a0b33a8cb753d9fb3d9a45026ce">ug::PrimalSubassembledMatrixInverse&lt; algebra_type &gt;</a>, <a class="el" href="classug_1_1_agglomerating_solver.html#a2b77df9ba46b519a10b795c21d7b1778">ug::AgglomeratingSolver&lt; TAlgebra &gt;</a>, <a class="el" href="classug_1_1_bi_c_g_stab.html#a65eea21dbee708a12dfa101f3aef77c3">ug::BiCGStab&lt; TVector &gt;</a>, <a class="el" href="classug_1_1_auto_linear_solver.html#aae0f03f14958223c7ef45a7ebee4ef29">ug::AutoLinearSolver&lt; TVector &gt;</a>, <a class="el" href="classug_1_1_i_external_solver.html#ac9efc2942fb509978d32becd42d8cc30">ug::IExternalSolver&lt; TAlgebra &gt;</a>, <a class="el" href="classug_1_1_g_m_r_e_s.html#a8cbae88bbbba018e5eb2518ca3e67677">ug::GMRES&lt; TVector &gt;</a>, <a class="el" href="classug_1_1_c_g.html#a2240ded21e57bd0c1cc92bc42aab56a8">ug::CG&lt; TVector &gt;</a>, <a class="el" href="classug_1_1_l_u.html#af1e71fcda9879c4d903f71edc19b26cb">ug::LU&lt; TAlgebra &gt;</a>, <a class="el" href="classug_1_1_linear_solver.html#aea50b74ba0a064f5fab93a4ec6128680">ug::LinearSolver&lt; TVector &gt;</a>, <a class="el" href="classug_1_1_linear_solver.html#aea50b74ba0a064f5fab93a4ec6128680">ug::LinearSolver&lt; ug::CPUAlgebra::vector_type &gt;</a>, and <a class="el" href="classug_1_1_analyzing_solver.html#af140f3178ba77e6e9eb3f6f917d0de17">ug::AnalyzingSolver&lt; M, X, Y &gt;</a>.</p>

<p>Referenced by <a class="el" href="classug_1_1_i_linear_operator_inverse.html#afce875833c261332bd02e8aee36ca4de">ug::ILinearOperatorInverse&lt; TVector &gt;::config_string()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="ae2d8ea239673ca5802ded71a6e078891"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename X, typename Y = X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt;<a class="el" href="classug_1_1_i_convergence_check.html">IConvergenceCheck</a>&lt;X&gt; &gt; <a class="el" href="classug_1_1_i_linear_operator_inverse.html">ug::ILinearOperatorInverse</a>&lt; X, Y &gt;::m_spConvCheck</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>smart pointer holding the convergence check </p>

<p>Referenced by <a class="el" href="classug_1_1_i_linear_operator_inverse.html#ac399dff427d4ab1dfcd43cfa8b0ecacf">ug::ILinearOperatorInverse&lt; TVector &gt;::convergence_check()</a>, and <a class="el" href="classug_1_1_i_linear_operator_inverse.html#a78adf42b534f257a9918c11a20887db8">ug::ILinearOperatorInverse&lt; TVector &gt;::set_convergence_check()</a>.</p>

</div>
</div>
<a class="anchor" id="a2a748ce95370ee20696cfda586a47d5c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename X, typename Y = X&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_smart_ptr.html">SmartPtr</a>&lt;<a class="el" href="classug_1_1_i_linear_operator.html">ILinearOperator</a>&lt;Y,X&gt; &gt; <a class="el" href="classug_1_1_i_linear_operator_inverse.html">ug::ILinearOperatorInverse</a>&lt; X, Y &gt;::m_spLinearOperator</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operator that is inverted by this Inverse Operator. </p>

<p>Referenced by <a class="el" href="classug_1_1_i_linear_operator_inverse.html#adf947e1fcaeed6ab77defbfff7939ede">ug::ILinearOperatorInverse&lt; TVector &gt;::init()</a>, and <a class="el" href="classug_1_1_i_linear_operator_inverse.html#a3608d8640ae456c216751226adef469a">ug::ILinearOperatorInverse&lt; TVector &gt;::linear_operator()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>ugbase/lib_algebra/operator/interface/<a class="el" href="linear__operator__inverse_8h_source.html">linear_operator_inverse.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceug.html">ug</a></li><li class="navelem"><a class="el" href="classug_1_1_i_linear_operator_inverse.html">ILinearOperatorInverse</a></li>
    <li class="footer">Generated on Wed Jan 13 2016 12:43:08 for ug4 by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
